<!DOCTYPE html>
<html>
  <head>
    <title>Project1 Write-up (Yueqing Feng, Jiachen Lian)</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
      }
      header {
        background-color: #333;
        color: #fff;
        padding: 1rem;
      }
      h1, h2 {
        margin: 1rem 0;
      }
      code {
        background-color: #eee;
        padding: 0.5rem;
        margin: 0.5rem 0;
        display: block;
      }
      img {
        max-width: 100%;
        display: block;
        margin: 1rem 0;
      }
      section {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
      }
    </style>
  </head>
  <body>
    <h1>Project Write-up (Yueqing Feng & Jiachen Lian)</h1>
    <h2>Overview</h2>
    <p><!-- Your overview goes here --></p>

    <h2>Task 1</h2>
    <p>In the implementation of triangle rasterization, the core idea is to check if a point is inside
		the triangle. However, it is pretty inefficient to check all points in the bounding box. So inspired the idea of 
		how rasterizing line happens, our idea is to only look at theb points that near the triangle. Specifically, we first get
		the minimum value of x and y coordinate of the triangle. All points out of these boundries will not be considered. The code for this is as follows:
	</p>

	<pre>
		<code>
		    for (int i = ceil(x_min - 0.5); i <= floor(x_max + 0.5); i++){ 
			        for (int j = ceil(y_min - 0.5); j <= floor(y_max + 0.5); j++){...
					}
				}
	</code>
	</pre>

	<p>
	The next core part is to judge of the point is in the triangle. There are many ways to check this. We use barycentric coordinates to achieve this.
	Specifically, we compute the barycentric coordnates of the current point: u, v and (1-u-v). The condition is just that all of these coordinates are non-negative. This is shown as below:
	</p>

	<pre>
		<code>
	  bool RasterizerImp::inside_triangle(float p_x, float p_y,
		  float x0, float y0,
		  float x1, float y1,
		  float x2, float y2) {
		float det_T = (x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0);
		float det_T1 = (p_x - x0) * (y2 - y0) - (p_y - y0) * (x2 - x0);
		float det_T2 = (x1 - x0) * (p_y - y0) - (y1 - y0) * (p_x - x0);
		float u = det_T1 / det_T;
		float v = det_T2 / det_T;
	  
		return u >= 0 && v >= 0 && (u + v) <= 1;
	  }
		</code>
	  </pre>

	  <p>
		We visualize the rasterization result of test4.svg showing below. As we zoom in to some parts (shown in Fig 1-2, 1-3, 1-4), there are aliases or discontinuous parts (sampling artifacts). 
		This is due to multiple factors. One major reason would be that the sampling rate is lower than the highest frequency in the original images. 
	</p>	

	  <h3>Image Results</h3>
	  <div style="display: flex; flex-wrap: wrap;">
		<div style="flex: 10%; padding: 5px; text-align: center">
		  <img src="imgs/img1.png" alt="Image 1">
		  <div class="caption">Fig 1-1</div>
		</div>
		<div style="flex: 10%; padding: 5px; text-align: center">
		  <img src="imgs/img2.png" alt="Image 2">
		  <div class="caption">Fig 1-2</div>
		</div>
		<div style="flex: 10%; padding: 5px; text-align: center">
		  <img src="imgs/img3.png" alt="Image 3">
		  <div class="caption">Fig 1-3</div>
		</div>
		<div style="flex: 10%; padding: 5px; text-align: center">
		  <img src="imgs/img4.png" alt="Image 4">
		  <div class="caption">Fig 1-4</div>
		</div>
	  </div>



    <h2>Task 2</h2>
    <p>We can think two aspects of the reason why supersampling is helpful. First, the increased sampling rate would be closer to the highest frequency in the original image. Second, supersampling acts as a filter to "filter out" the high frequency
		components in the original image. The first point is more heuristic while the second one is more formal. 
	</p>
	<br>
	<p>
		In my implementation, at each pixel, I would sample "sampling rate" points. I attach the core code below:
	</p>	
	<pre>
		<code>
			for (int i = 0; i < width; i++){
				if (i < x_min - 1 || i > x_max + 1) continue;
				for (int j = 0; j < height; j++){
					if (j < y_min - 1 || j > y_max + 1) continue;
					for (int sub_i = 0; sub_i < num_per_pixel; sub_i++){
						for (int sub_j = 0; sub_j < num_per_pixel; sub_j++){
							float p_x = i + float((sub_i + 1) * 2 -1)  / float(num_per_pixel * 2);
							float p_y = j + float((sub_j + 1) * 2 - 1) / float(num_per_pixel * 2);
							if (inside_triangle(p_x, p_y, x0, y0, x1, y1, x2, y2)){
								sample_buffer[sample_rate * (i * height + j) + sub_i * num_per_pixel + sub_j] = color;
							}
						}
					}
				}
			}
	</code>
	</pre>

	<p>
		where p_x and p_y is the x and y coordinate for all "sampling rate" sample points. We also updated the sample buffer to increase the capacity of it. Note that once we have "sampling rate" sample points, we then average the colors:
	</p>

	<pre>
		<code>
			void RasterizerImp::resolve_to_framebuffer() {
				// TODO: Task 2: You will likely want to update this function for supersampling support
				int num_per_pixel = sqrt(this->sample_rate);
				for (int i = 0; i < width; i++) {
				  for (int j = 0; j < height; j++) {
					Color actual_col;
			
					for (int sub_i = 0; sub_i < num_per_pixel; sub_i++){
						for (int sub_j = 0; sub_j < num_per_pixel; sub_j++){
							float p_x = i + float((sub_i + 1) * 2 -1)  / float(num_per_pixel * 2);
							float p_y = j + float((sub_j + 1) * 2 - 1) / float(num_per_pixel * 2);
							Color color_new = this->sample_buffer[sample_rate * (i * height + j) + sub_i * num_per_pixel + sub_j];
							if (sub_i == 0 && sub_j == 0){
								actual_col = color_new;
							}
							else{
								actual_col += color_new;  //we are going to take the average of colors
							}
					  }
					}
			
					//This is the actual color which is averaged over all sub-pixels in one pixel.
					actual_col = actual_col * (1.0 / this->sample_rate);
			
					for (int k = 0; k < 3; ++k) {
					  this->rgb_framebuffer_target[3 * (j * width + i) + k] = (&actual_col.r)[k] * 255;
					}
			
				  }
				}
			  }	
		</code>
	</pre>

	<h3>Image Results</h3>
	<div style="display: flex; flex-wrap: wrap;">
	  <div style="flex: 10%; padding: 5px; text-align: center">
		<img src="imgs/img2_1.png" alt="Image 1">
		<div class="caption">Fig 2-1 (sr=1)</div>
	  </div>
	  <div style="flex: 10%; padding: 5px; text-align: center">
		<img src="imgs/img2_2.png" alt="Image 2">
		<div class="caption">Fig 2-2 (sr=4)</div>
	  </div>
	  <div style="flex: 10%; padding: 5px; text-align: center">
		<img src="imgs/img2_3.png" alt="Image 3">
		<div class="caption">Fig 2-3 (sr=16)</div>
	  </div>
	</div>

	<p>
		As we can see in the above figures, as we increase sampling rate, we get "smoother" results. This is because higher sampling-rate filter out the higher frequency components in the orginal svg file.
	</p>

    <h2>Task 3</h2>
    <p><!-- Your explanation for Task 3 goes here --></p>
    <img src="path/to/my_robot.png" alt="my_robot screenshot">

    <h2>Task 4</h2>
    <p><!-- Your explanation for Task 4 goes here --></p>
    <img src="path/to/test7.png" alt="test7 screenshot">

    <h2>Task 5</h2>
    <p><!-- Your explanation for Task 5 goes here --></p>
    <img src="path/to/texmap_nearest_1.png" alt="texmap nearest 1 screenshot">
    <img src="path/to/texmap_nearest_16.png" alt="texmap nearest 16 screenshot">
    <img src="path/to/texmap_bilinear_1.png" alt="texmap bilinear 1 screenshot">
    <img src="path/to/texmap_bilinear_16.png" alt="texmap bilinear 16 screenshot">

    <h2>Task 6</h2>
    <p><!-- Your explanation for Task 6 goes here --></p>
    <img src="path/to/my_texmap_L0PNEAREST.png" alt="my_texmap L0 PNEAREST screenshot">
    <img src="path/to/my_texmap_L0PLINEAR.png" alt="my_texmap L0 PLINEAR screenshot">
    <img src="path/to/my_texmap_LNEARESTPNEAREST.png" alt="my_texmap LNEAREST PNEAREST screenshot">
    <img src="path/to/my_texmap_LNEARESTPLINEAR.png" alt="my_texmap LNEAREST PLINEAR screenshot">
  </body>
</html>
